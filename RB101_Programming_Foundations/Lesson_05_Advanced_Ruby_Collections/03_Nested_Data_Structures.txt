
################# NESTED DATA STRUCTURES

###### REFERENCING COLLECTION ELEMENTS

  arr = [[1, 3], [2]] = [ [arr[0][0], arr[0][1]], [arr[1][0]] ] = [arr[0], arr[1]]
            |     |
       inner array|
         arr[0]   |
                  |
             inner array
               arr[1]


  arr[0] = [1, 3]
  arr[0][0] = 1
  arr[0][1] = 3

  arr[1] = [2]
  arr[1][0] = 2


###### UPDATING COLLECTION ELEMENTS

It's a 'destructive' action that will change the original array. Example:

  arr = [[1, 3], [2]]
  arr[0][1] = 5
  # => [[1, 5], [2]]

We can add elements:

  arr = [[1], [2]]

  arr[0] << 3
or
  arr[0][1] = 3
  # => [[1, 3], [2]]


###### OTHER NESTED STRUCTURES

  arr = [{ a: 'ant' }, { b: 'bear' }] = [ arr[0], arr[1] ]

To add a new key/value into the first inner hash:

  arr[0][:c] = 'cat'
  => [{:a=>"ant", :c=>"cat"}, {:b=>"bear"}]


Some examples:

arr = [['a', ['b']], { b: 'bear', c: 'cat' }, 'cab']

arr[0]          # ['a', ['b']
arr[0][1][0]    # "b"
arr[1]          # { b: 'bear', c: 'cat' }
arr[1][:b]      # "bear"
arr[1][:b][0]   # "b"
arr[2][2]       # "b"


###### VARIABLE REFERENCE FOR NESTED COLLECTIONS

Placing local variable inside an array looks like adding elements to it, but
we have to notice a particular behavior:

  a = [1, 3]
  b = [2]
  arr = [a, b]
  arr # => [[1, 3], [2]]

Let's add a new element to the second inner array:

  a[1] = 5
  arr # => [[1, 5], [2]]

this is going to change the original 'a' array:
  
  a[1]
  # => 5 
  a
  # => [1, 5]

Same result if we do like this:

  arr[0][1] = 5

because:

  BOTH 'arr[0]' AND 'a' ARE REFERENCING THE SAME OBJECT.


###### SHALLOW COPY









