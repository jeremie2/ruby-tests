
:::::::::::::::::::::::ASSIGNMENT: RPS BONUS FEATURES
(RPS: Rock Paper Scissors)

Starting from file: 22_rubocop_rock_paper_scissors.rb


::::::::::::::::::::::::::::::::::::::::::::::::::::
:::: 1. LIZARD SPOCK :::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::
:::: file: 23_lizard_spock_1.rb ::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::

The goal of this bonus is to add Lizard and Spock into your code following
the rules:

  - Scissors cuts Paper
  - Paper covers Rock
  - Rock crushes Lizard
  - Lizard poisons Spock
  - Spock smashes Scissors
  - Scissors decapitates Lizard
  - Lizard eats Paper
  - Paper disproves Spock
  - Spock vaporizes Rock
  - Rock crushes Scissors


To have an updated and working program all we have to do is:
1. Insert 'lizard' and 'spock' inside VALID_CHOICES:

     VALID_CHOICES = %w(rock paper scissors spock lizard)

2. Update win?(first, second) adding conditions with 'lizard' and 'spock':

     def win?(first, second)
       (first == 'rock' && second == 'scissors') ||
       (first == 'rock' && second == 'lizard') ||
       (first == 'paper' && second == 'rock') ||
       (first == 'paper' && second == 'spock') ||
       (first == 'scissors' && second == 'paper') ||

       ......... and so on!
     end

At this stage the program works... BUT...

      Rubocop COMPLAINTS because win?() is actually too messy.

I decided to re-base the method:

1. Created a new constant:
   
   WIN_COMBINATIONS = [%w(paper rock), %w(paper spock), %w(rock scissors),
                    %w(rock lizard), %w(scissors paper), %w(scissors lizard),
                    %w(lizard spock), %w(lizard paper), %w(spock rock),
                    %w(spock scissors)]

   WIN_COMBINATIONS is an array containing several arrays made of couple
   of strings. These pairs are all the possible winning combinations.
   The first string is the winning one: 
      
      %w(paper rock) => paper wins

2. Now win?() method can be simplified:

     def win?(first, second)
       WIN_COMBINATIONS.include?([first, second])
     end

     win?() is just checking that the assigned pair is included in 
     IN_COMBINATIONS. In that case it returns true.

3. Changed display_result() with result():

     def result(player, computer)
       if win?(player, computer)
         'You won!'
       elsif win?(computer, player)
         'Computer won!'
       else
         "It's a tie."
       end
     end

   Now the method just return strings.
   THis means that to display the result we have to prompt it:

      (result(choice, computer_choice))


::::::::::::::::::::::::::::::::::::::::::::::::::::
:::: 2. NOT TYPING THE FULL WORD :::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::
:::: file: 23_lizard_spock_2.rb ::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::

Typing the full word "rock" or "lizard" is tiring. Update the program
so the user can type "r" for "rock," "p" for "paper," etc.
Note that if you do bonus #1, you'll have two words that start with "s."
How do you resolve that?

1. Instead of:

     VALID_CHOICES = %w(rock paper scissors spock lizard)

   I have set:

     VALID_CHOICES = %w(r p sc sp l)

2. I've created the following hash:

     SELECT_ITEM = { 'r' => 'rock',
                     'p' => 'paper',
                     'sc' => 'scissors',
                     'sp' => 'spock',
                     'l' => 'lizard' }

3. Inside the loop instead of:

     loop do
       prompt("Choose one: #{VALID_CHOICES.join(', ')}")
       choice = Kernel.gets().chomp()
       if VALID_CHOICES.include?(choice)
         break
       ......

   I've altered the code:

    loop do
      prompt(CHOOSE)
      choice = Kernel.gets().chomp().downcase()
      if VALID_CHOICES.include?(choice)
        choice = SELECT_ITEM[choice]
        break

   CHOOSE is better way to style the prompted string:

   CHOOSE = <<-MSG
     Choose one:
     r) rock
     p) paper
     sc) scissors
     sp) spock
     l) lizard
   MSG

   so that the user can read better the available options.
   If valid choice is correct, then choice will be set.
   Example:
 
     choice = 'l'
     choice = SELECT_ITEM['l'] => 'lizard'

4. Finally the computer_choice has been updated.
   From:

     computer_choice = VALID_CHOICES.sample

   to:

     computer_choice = SELECT_ITEM[VALID_CHOICES.sample]
