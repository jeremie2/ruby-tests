
::::::::: DEBUGGING

Debugging is the core activity of programming. Most of the time is spent trying to
solve problems we meet while coding.


::: TEMPERAMENT

Having a patient, systematic and logical temperament helps.
Programming is dealing with a constant stream of broken things. This means we have
to be prepared to deal with that bad feeling carried by broken thing.
Instead of sinking into sadness, it's important to react trying to understand:
why code breaks, what's the possible solution or alternative, etc...


::: READING ERROR MESSAGES

Running into an error means to have in front a STACK TRACE. It's possible that it
will show a huge amount of information, but the important thing is to spot errors
like "NoMethodError: undefined method `name' for nil:NilClass".
Here is where we get the first hint to understand the problem.

If the error message makes sense, it's possible to go through the code to fix what
is wrong. Otherwise, if we don't have any clue, it's time to find some documentation.


::: ONLINE RESOURCES

- Documentation:
  The official https://ruby-doc.org/ one of the best place where to look.
  If the official doc looks too cryptic, go to search engines!

- Search Engine:
  It's a good thing to search the whole string "NoMethodError: undefined method `name'
  for nil:NilClass". But.. some information might be too specific like 'name'. If you
  don't get infos, try to search without 'name'.
  Avoid using other specific info like personal directories (/home/user_name/..).
  If you find links related to other programming language, just preface "Ruby" in
  front of the message.

- Stack Overflow:
  https://stackoverflow.com/ results will probably appear, as this is the largest
  collection of answer to code problems in the web. If not, it might be worth to
  search directly on stackoverflow.com.

  
::: STEPS TO DEBUGGING

1. Reproduce the Error:
   Programmers need a deterministic way to consistently reproduce the problem, and only
   then we can start to isolate the root cause.
   Your app can get more sophisticated, including external dependencies. The app works
   on your system but fails on another. Being able to reproduce the error is a big help
   to solve the problem.

2. Determine the Boundaries of the Error
   For example, the stack trace earlier was generated by this code post.categories << news
   Does calling post.categories cause issues? What about just calling post? What happens
   if we try to append a different object, like this: post.categories << sports? How does
   modifying the data affect the program behavior? Do we get expected errors, or does a
   new error occur that sheds light on the underlying problem?

   This help to understand the scope of the error and build a proper solution.


2. Trace the Code
   Here an example of bug:
    ______________________________________________
    def car(new_car)
      make = make(new_car)
      model = model(new_car)
      [make, model]
    end

    def make(new_car)
      new_car.split(" ")[0]
    end

    def model(new_car)
      new_car.split(" ")[2]
    end

    make, model = car("Ford Mustang")
    make == "Ford"         # => true
    model.start_with?("M") # => NoMethodError: undefined method `start_with?' for nil:NilClass
    __________________________

    make, model = car("Ford Mustang") is a MULTIPLE ASSIGNMENT
    it should work like this: make, model = ['Ford', 'Mustang']
    so that make = 'Ford' and model = 'Mustang'

    We get an error when the program is checking whether model starts with 'M'.
    (And it should because model should be = 'Mustang').
    
    Let's see what the program does:
    1. car() takes a string as argument (new_car)
    2. inside car() two variable are initialized: make and model
    3. the two variable are initialized with two helper methods:
       make(new_car) and model(new_car)
    4. car() will finally return an array: [make, model]
    5. make(new_car):
       make(new_car) returns new_car.split(" ")[0]
       which is "Ford Mustang".split(" ")[0]
       .split(" ") divides the string like this ['Ford', 'Mustang']
       the [0] means the first element of the array 'Ford'
    6. model(new_car):
       if the previous method returns the make, it's quite obvious that
       model method returns the model, which should be 'Mustang'
       but the code state new_car.split(" ")[2] and.. HERE IS THE ERROR!
       in the array there are 2 elements, the second position is [1] not [2]
       
       def model(new_car)
         new_car.split(" ")[1]
       end
       
       end the program works!


3. Implement a fix

When possible we act directly on our code, but sometimes the error is in
a external library and an immediate fix is not possible.
In that case we have to handle the problem.

In some cases we can use the 'rescue' clause like this:

  model.start_with?("M") rescue false

But this just jumps over the problem without solving it.
In some cases this could create even worse problems.


4. Test the fix

Later on we'll learn about automated tests.


::: TECHNIQUES FOR DEBUGGING

1. Line by Line
   Your best debugging tool is your patience... most error comes from little details.
   Being careful, patient and developing a habit of reading code line-by-line,
   word-by-word, character-by-character is your most powerful ability as a programmer.

2. Rubber Duck
   https://en.wikipedia.org/wiki/Rubber_duck_debugging
   Another way to say 'Line by Line' :)
   Anyway, trying to explain something to someone that doesn't know the topic, is one 
   of the best way of not give anything for granted.
   
3. Walking Away
   After having spent a long time on a problem, it's possible that the brain is tired or
   in some way is at the moment not able to exit from a dead end loop.
   Doing something else will refresh the mind, while actually the brain is still working
   in background.
   Often, after a pause, it happens that you see the problem from a different point of view
   and find a maybe obvious solution.
   
4. Using Pry
   Pry is a more powerful alternative to Irb REPL.
   We can use it to debug in a interactive mode putting:
   
   require "pry"    # on top
   binding.pry      # where we wont inside a program
   
   let's see an example inside a loop:
   
    require "pry" 
    counter = 0

    loop do
      counter += 1
      break if counter == 1
      binding.pry
    end
   
    ## in this case nothing happens because the loop exit before reaching binding.pry
    ## but changing 'break if counter == 5'

    require "pry" 
    counter = 0

    loop do
      counter += 1
      break if counter == 5
      binding.pry
    end
   
    ## we'll see this:
    
     3: counter = 0
     4: 
     5: loop do
     6:   counter += 1
     7:   break if counter == 5
 =>  8:   binding.pry
     9: end
    10: 

    [1] pry(main)> 

    ## we can see the actual value of 'counter':

    [1] pry(main)> counter
    => 1

    ## we can move one step the loop pressing Ctrl+D
    ## and this time we can see the updated value of 'counter':

    [1] pry(main)> counter 
    => 2

    ## This can be very helpful instead breaking the code with endless 'puts'.
    ## To exit:
    
    exit-program

    ## or pressing Ctrl+Z


4. Using a Debugger
   Pry can be used as a debugger, but at the moment this is an advanced topic.
   
